!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], t)
    : t(((e = 'undefined' != typeof globalThis ? globalThis : e || self).limu = {}));
})(this, function (e) {
  'use strict';
  const t = Symbol('M'),
    r = Symbol('IMMUT_BASE'),
    n = 'Map',
    o = 'Set',
    a = 'Array',
    s = { Map: n, Set: o, Array: a },
    c = '[object Object]',
    i = '[object Map]',
    u = '[object Set]',
    f = '[object Array]',
    l = '[object Function]',
    p = { [i]: n, [u]: o, [f]: a, [c]: 'Object' },
    y = ['push', 'pop', 'shift', 'splice', 'unshift', 'reverse', 'copyWithin', 'delete', 'fill'],
    d = ['set', 'clear', 'delete'],
    m = ['add', 'clear', 'delete'],
    h = [
      'concat',
      'copyWithin',
      'entries',
      'every',
      'fill',
      'filter',
      'find',
      'findIndex',
      'flat',
      'flatMap',
      'forEach',
      'includes',
      'indexOf',
      'join',
      'keys',
      'lastIndexOf',
      'map',
      'pop',
      'push',
      'reduce',
      'reduceRight',
      'reverse',
      'shift',
      'unshift',
      'slice',
      'some',
      'sort',
      'splice',
      'values',
      'valueOf',
    ],
    v = {
      [n]: ['clear', 'delete', 'entries', 'forEach', 'get', 'has', 'keys', 'set', 'values'],
      [o]: ['add', 'clear', 'delete', 'entries', 'forEach', 'has', 'keys', 'values'],
      [a]: h,
    },
    b = { [n]: ['clear', 'set', 'delete'], [o]: ['clear', 'add', 'delete'], [a]: h },
    M = { [n]: ['forEach', 'get'], [o]: ['forEach'], [a]: ['forEach', 'map'] },
    P = { value: 0, usablePrefix: 1 },
    O = { autoFreeze: !1, usePatches: !1, fastModeRange: 'array' },
    g = Object.prototype.toString;
  function k(e) {
    return g.call(e);
  }
  function j(...e) {
    return e;
  }
  function x(e) {
    return k(e) === c;
  }
  function w(e) {
    return k(e) === i;
  }
  function E(e) {
    return k(e) === u;
  }
  function D(e) {
    return k(e) === l;
  }
  function T(e) {
    const t = k(e);
    return ![c, f, i, u, l].includes(t);
  }
  function V(e) {
    return 'AsyncFunction' === e.constructor.name || 'function' == typeof e.then;
  }
  function _(e) {
    return 'undefined' != typeof Promise && e instanceof Promise;
  }
  function B(e) {
    var t = typeof e;
    return 'number' === t || ('string' === t && /^[0-9]*$/.test(e));
  }
  function S(e) {
    return 'symbol' == typeof e;
  }
  const A = { [f]: Array.prototype, [i]: Map.prototype, [u]: Set.prototype, [l]: Function.prototype };
  function F(e) {
    e.rootMeta.modified = !0;
    const t = (e) => {
      e && !e.modified && ((e.modified = !0), t(e.parentMeta));
    };
    t(e);
  }
  function z(e, r, n, o) {
    return (
      n
        ? (e[t] = r)
        : (!(function (e, t) {
            const r = k(e),
              n = A[r] || Object.prototype,
              o = Object.create(null);
            t && Object.assign(o, t), Object.setPrototypeOf(o, n), Object.setPrototypeOf(e, o);
          })(e, o),
          (e.__proto__[t] = r)),
      e
    );
  }
  function R(e, t) {
    const { finishDraft: r, ver: n, parentMeta: o = null, key: a, immutBase: s, compareVer: c } = t,
      i = ((u = k(e)), p[u]);
    var u;
    let f = [],
      l = 0,
      y = null;
    o &&
      ((y = o.copy),
      (l = (function (e) {
        const t = C(e);
        return t ? t.level + 1 : 1;
      })(y)),
      (f = (function (e, t) {
        const r = [t],
          n = N(e);
        if (n && n.level > 0) {
          const { keyPath: e } = n;
          return [...e, t];
        }
        return r;
      })(y, a)));
    const d = {
      rootMeta: null,
      parentMeta: o,
      parent: y,
      selfType: i,
      self: e,
      copy: null,
      key: a,
      keyPath: f,
      level: l,
      proxyVal: null,
      proxyItems: null,
      modified: !1,
      scopes: [],
      isImmutBase: s,
      isDel: !1,
      isFast: !1,
      newNodeStats: {},
      linkCount: 1,
      finishDraft: r,
      ver: n,
      compareVer: c,
      revoke: j,
    };
    return (d.rootMeta = 0 === l ? d : o.rootMeta), d;
  }
  function I(e) {
    if (T(e)) return !1;
    const t = C(e);
    return !!t && !t.isImmutBase;
  }
  function N(e) {
    return e[t];
  }
  function C(e) {
    return (e && e[t]) || null;
  }
  function $(e, t) {
    const r = C(e),
      n = C(t);
    if (!r && !n) return !Object.is(e, t);
    const { self: o, modified: a, compareVer: s, ver: c, level: i } = r || { self: e, modified: !1, compareVer: !1, ver: '0', level: 0 },
      { self: u, modified: f, compareVer: l, ver: p, level: y } = n || { self: t, modified: !1, compareVer: !1, ver: '0', level: 0 };
    return o !== u || !((!s && !l) || (0 !== i && 0 !== y) || c === p) || a || f;
  }
  function K(e) {
    const t = (e) => {
      if (T(e)) return e;
      let r = e;
      if (
        (Array.isArray(e) &&
          ((r = e.slice()),
          r.forEach((e, n) => {
            r[n] = t(e);
          })),
        E(e))
      ) {
        const n = Array.from(e);
        n.forEach((e, r) => {
          n[r] = t(e);
        }),
          (r = new Set(n));
      }
      return (
        w(e) &&
          ((r = new Map(e)),
          r.forEach((e, n) => {
            r.set(n, t(e));
          })),
        x(e) &&
          ((r = {}),
          Object.keys(e).forEach((n) => {
            r[n] = t(e[n]);
          })),
        r
      );
    };
    return t(e);
  }
  function U(e, t, r) {
    const { extraProps: n } = r,
      { copy: o, fast: s } = (function (e, t) {
        const { parentType: r, fastModeRange: n } = t;
        if (Array.isArray(e)) return { copy: e.slice(), fast: !1 };
        const o = ('array' === n && r === a) || 'all' === n;
        let s = e;
        return e && x(e) && (s = Object.assign({}, e)), w(e) && (s = new Map(e)), E(e) && (s = new Set(e)), { copy: s, fast: o };
      })(e, r);
    return z(o, t, s, n), { copy: o, fast: s };
  }
  function W(e) {
    const { self: r, copy: s, modified: c } = e;
    let i = r;
    return (
      s && c && (i = e.copy),
      (function (e) {
        e.scopes.forEach((e) => {
          const { modified: r, copy: s, parentMeta: c, key: i, self: u, revoke: f, proxyVal: l, isDel: p, isFast: y } = e;
          if (!s) return f();
          if ((y ? delete s[t] : delete s.__proto__[t], !c)) return f();
          const d = r ? s : u,
            m = c.copy,
            h = c.selfType;
          return h === n ? (m.set(i, d), f()) : h === o ? (m.delete(l), m.add(d), f()) : h === a || !0 !== p ? ((m[i] = d), f()) : void 0;
        }),
          (e.scopes.length = 0);
      })(e),
      i
    );
  }
  function G(e) {
    e.rootMeta.scopes.push(e);
  }
  function J(e, t) {
    const {
        finishDraft: r = j,
        ver: n,
        traps: o,
        parentType: a,
        parentMeta: s,
        key: c,
        fastModeRange: i,
        immutBase: u,
        extraProps: f,
        compareVer: l = !1,
      } = t,
      p = R(e, { finishDraft: r, ver: n, parentMeta: s, key: c, immutBase: u, compareVer: l }),
      { copy: y, fast: d } = U(e, p, { parentType: a, fastModeRange: i, extraProps: f });
    if (((p.copy = y), (p.isFast = d), u)) {
      const e = new Proxy(y, o);
      (p.proxyVal = e), (p.revoke = j);
    } else {
      const e = Proxy.revocable(y, o);
      (p.proxyVal = e.proxy), (p.revoke = e.revoke);
    }
    return p;
  }
  function L(e, t) {
    const {
      key: r,
      parentMeta: s,
      ver: c,
      traps: i,
      parent: u,
      patches: f,
      inversePatches: l,
      usePatches: p,
      parentType: y,
      fastModeRange: d,
      immutBase: m,
      readOnly: h,
      extraProps: v,
      compareVer: b,
    } = t;
    let P = e;
    if (h && s && !D(e)) {
      const { copy: e, self: t } = s,
        n = t[r];
      (e[r] = n), (P = n);
    }
    const O = (e, t) => {
      const r = t || '';
      if (T(e) || !e) return e;
      if (!s) throw new Error('[[ createMeta ]]: meta should not be null');
      if (!D(e)) {
        if (s.newNodeStats[r]) return e;
        let t = N(e);
        return (
          t ||
            ((t = J(e, {
              key: r,
              parentMeta: s,
              parentType: y,
              ver: c,
              traps: i,
              fastModeRange: d,
              immutBase: m,
              readOnly: h,
              extraProps: v,
              compareVer: b,
            })),
            G(t),
            (u[r] = t.copy)),
          t.proxyVal
        );
      }
      if (
        !(function (e, t) {
          return e === a || (M[e] || []).includes(t);
        })(y, r)
      )
        return e;
      if (s.proxyItems) return e;
      let P = [];
      if (y === o) {
        const e = new Set();
        u.forEach((t) => e.add(O(t))),
          q(e, s, { dataType: o, patches: f, inversePatches: l, usePatches: p }),
          (P = z(e, s, d, v)),
          (s.copy = P);
      } else if (y === n) {
        const e = new Map();
        u.forEach((t, r) => e.set(r, O(t, r))),
          q(e, s, { dataType: n, patches: f, inversePatches: l, usePatches: p }),
          (P = z(e, s, d, v)),
          (s.copy = P);
      } else y === a && 'sort' !== r && ((s.copy = s.copy || u.slice()), (P = s.proxyVal));
      return (s.proxyItems = P), e;
    };
    return O(P, r);
  }
  function X(e) {
    if (!x(e)) return e;
    const t = N(e);
    return t ? t.copy : e;
  }
  function q(e, t, r) {
    const { dataType: a } = r,
      s = e.delete.bind(e),
      c = e.clear.bind(e);
    if (
      ((e.delete = function (...e) {
        return F(t), s(...e);
      }),
      (e.clear = function (...e) {
        return F(t), c(...e);
      }),
      a === o)
    ) {
      const n = e.add.bind(e);
      e.add = function (...e) {
        return F(t), Object.assign({ meta: t }, r), n(...e);
      };
    }
    if (a === n) {
      const n = e.set.bind(e);
      e.set = function (...e) {
        return F(t), Object.assign({ meta: t }, r), n(...e);
      };
    }
  }
  function H(e, t) {
    const { op: r, key: s, value: c, calledBy: i, parentType: u, parentMeta: f } = t,
      l = X(c);
    if (!f) return void (e[s] = l);
    const { self: p, copy: h } = f;
    !(function (e) {
      const { calledBy: t, parentMeta: r, op: s, parentType: c } = e;
      (['deleteProperty', 'set'].includes(t) ||
        ('get' === t && ((c === o && m.includes(s)) || (c === a && y.includes(s)) || (c === n && d.includes(s))))) &&
        F(r);
    })({ calledBy: i, parentMeta: f, op: r, key: s, parentType: u });
    const b = v[u] || [];
    if (D(c) && b.includes(r)) return 'slice' === r ? p.slice : h ? (u === o || u === n ? h[r].bind(h) : h[r]) : p[r].bind(p);
    if (!h) return l;
    const M = h[s],
      P = () => {
        const e = C(M);
        e && (e.isDel = !0);
      };
    if ('deleteProperty' === i) {
      const e = C(c);
      return e ? (e.isDel = !0) : P(), void delete h[s];
    }
    h[s] || T(l) || (f.newNodeStats[s] = !0),
      (h[s] = l),
      P(),
      (() => {
        const e = C(c);
        e &&
          e.isDel &&
          ((e.isDel = !1),
          (e.key = s),
          (e.keyPath = f.keyPath.concat([s])),
          (e.level = f.level + 1),
          (e.parent = f.copy),
          (e.parentMeta = f));
      })();
  }
  function Q(e) {
    if (T(e)) return e;
    if (Array.isArray(e) && e.length > 0) return e.forEach(Q), Object.freeze(e);
    if (E(e)) {
      const t = e;
      (t.add = () => t), (t.delete = () => !1), (t.clear = j);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    if (w(e)) {
      const t = e;
      (t.set = () => t), (t.delete = () => !1), (t.clear = j);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    return (
      Object.getOwnPropertyNames(e).forEach((t) => {
        Q(e[t]);
      }),
      Object.freeze(e)
    );
  }
  const Y = ['length', 'constructor', 'asymmetricMatch', 'nodeType', 'size'],
    Z = [a, o, n];
  function ee() {
    return console.error('can not mutate state at readOnly mode!'), !0;
  }
  function te(e) {
    var n, o, c, i, u;
    const f = e || {},
      l = f.onOperate,
      p = f.fastModeRange || O.fastModeRange,
      y = null !== (n = f[r]) && void 0 !== n && n,
      d = f.extraProps || null,
      m = null !== (o = f.readOnly) && void 0 !== o && o,
      h = null !== (c = f.compareVer) && void 0 !== c && c,
      M = null !== (i = f.autoFreeze) && void 0 !== i ? i : O.autoFreeze,
      g = null !== (u = f.usePatches) && void 0 !== u ? u : O.usePatches,
      k = (e, t, r) => {
        if (!r || !l) return;
        const { selfType: n, keyPath: o, self: a, copy: s } = r;
        let c = 'get' !== e,
          i = !1;
        if ((v[n] || []).includes(t)) {
          i = !0;
          c = (b[n] || []).includes(t);
        }
        l({ parentType: n, op: e, isBuiltInFnKey: i, isChange: c, key: t, keyPath: o, fullKeyPath: o.concat(t), value: s[t] || a[t] });
      },
      j = (() => {
        const e = (function () {
          P.value >= Number.MAX_SAFE_INTEGER ? ((P.value = 1), (P.usablePrefix += 1)) : (P.value += 1);
          const { value: e, usablePrefix: t } = P;
          return `${t}_${e}`;
        })();
        let r = !0;
        const n = [],
          o = [],
          c = {
            get: (r, i) => {
              let u = r[i];
              if ('toJSON' === i && Array.isArray(r)) return u;
              if ('__proto__' === i || i === t) return u;
              if (S(i)) return D(u) ? u.bind(r) : u;
              const f = N(r),
                l = null == f ? void 0 : f.selfType;
              return Z.includes(l) && Y.includes(i)
                ? f.copy[i]
                : ((u = L(u, {
                    key: i,
                    parentMeta: f,
                    parentType: l,
                    ver: e,
                    traps: c,
                    parent: r,
                    patches: n,
                    fastModeRange: p,
                    immutBase: y,
                    readOnly: m,
                    inversePatches: o,
                    usePatches: g,
                  })),
                  l === a && B(i)
                    ? (k('get', i, f), u)
                    : s[l]
                    ? ((u = H(r, {
                        op: i,
                        key: i,
                        value: u,
                        metaVer: e,
                        calledBy: 'get',
                        patches: n,
                        inversePatches: o,
                        usePatches: g,
                        parentType: l,
                        parentMeta: f,
                      })),
                      k('get', i, f),
                      u)
                    : (k('get', i, f), u));
            },
            set: (t, n, o) => {
              let s = o;
              if (m) return ee();
              if (I(o))
                if (((i = e), x((c = o)) && N(c).ver !== i)) r = !1;
                else if (((s = X(o)), s === t[n])) return !0;
              var c, i;
              const u = N(t);
              if (u && u.selfType === a) {
                if (u.copy && u.__callSet && B(n)) return (u.copy[n] = s), k('set', n, u), !0;
                u.__callSet = !0;
              }
              return H(t, { parentMeta: u, key: n, value: s, metaVer: e, calledBy: 'set' }), k('set', n, u), !0;
            },
            deleteProperty: (t, r) => {
              if (m) return ee();
              const n = N(t);
              return H(t, { parentMeta: n, op: 'del', key: r, value: '', metaVer: e, calledBy: 'deleteProperty' }), k('del', r, n), !0;
            },
            apply: function (e, t, r) {
              return e.apply(t, r);
            },
          };
        return {
          createDraft: (t) => {
            if (T(t)) throw new Error('base state can not be primitive');
            let r = t;
            const n = N(t);
            if (n) {
              if (y && n.isImmutBase) return n.proxyVal;
              r = n.self;
            }
            const o = J(r, {
              key: '',
              ver: e,
              traps: c,
              finishDraft: j.finishDraft,
              immutBase: y,
              readOnly: m,
              extraProps: d,
              compareVer: h,
            });
            return G(o), o.proxyVal;
          },
          finishDraft: (e) => {
            const t = N(e);
            if (!t) throw new Error('rootMeta should not be null!');
            if (0 !== t.level) throw new Error('can not finish sub draft node!');
            if (t.isImmutBase) return e;
            let n = W(t);
            return M && r && (n = Q(n)), n;
          },
        };
      })();
    return j;
  }
  const re = I,
    ne = $,
    oe = function (e, t, r = !0) {
      const n = r ? $ : Object.is;
      return !((e, t) => {
        for (let r in e) if (!(r in t)) return !0;
        for (let r in t) if (n(e[r], t[r])) return !0;
        return !1;
      })(e, t);
    },
    ae = {
      noop: j,
      isObject: x,
      isMap: w,
      isSet: E,
      isFn: D,
      isPrimitive: T,
      isPromiseFn: V,
      isPromiseResult: _,
      isSymbol: S,
      canBeNum: B,
      isDraft: re,
      isDiff: ne,
      shallowCompare: oe,
      getDraftMeta: C,
    };
  function se(e, t) {
    return te(t).createDraft(e);
  }
  function ce(e) {
    const t = C(e);
    let r = null;
    if ((t && (r = t.finishDraft), !r)) throw new Error('not a Limu draft!');
    return r(e);
  }
  function ie(e) {
    if (!D(e)) throw new Error('produce callback is not a function');
  }
  function ue(e, t, r) {
    ie(t);
    const n = se(e, r),
      o = t(n);
    return (
      (function (e, t) {
        if (V(e) || _(t)) throw new Error('produce callback can not be a promise function or result');
      })(t, o),
      ce(n)
    );
  }
  const fe = function (e, t, r) {
      if (!t || !D(t)) {
        const r = e,
          n = t;
        return ie(e), (e) => ue(e, r, n);
      }
      return ue(e, t, r);
    },
    le = Q;
  const pe = function (e) {
      const t = C(e);
      return t ? t.self : e;
    },
    ye = function (e) {
      const t = C(e);
      return t ? K(t.copy || t.self) : e;
    };
  (e.VER = '3.5.6'),
    (e.createDraft = se),
    (e.current = ye),
    (e.deepCopy = function (e) {
      return K(e);
    }),
    (e.deepFreeze = le),
    (e.finishDraft = ce),
    (e.getAutoFreeze = function () {
      return O.autoFreeze;
    }),
    (e.immut = function (e, t) {
      return te(Object.assign(Object.assign({}, t || {}), { readOnly: !0, [r]: !0 })).createDraft(e);
    }),
    (e.isDiff = ne),
    (e.isDraft = re),
    (e.limuUtils = ae),
    (e.original = pe),
    (e.produce = fe),
    (e.setAutoFreeze = function (e) {
      O.autoFreeze = e;
    }),
    (e.shallowCompare = oe),
    Object.defineProperty(e, '__esModule', { value: !0 });
});
