!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], t)
    : t(((e = 'undefined' != typeof globalThis ? globalThis : e || self).limu = {}));
})(this, function (e) {
  'use strict';
  const t = Symbol('M'),
    r = Symbol('IMMUT_BASE'),
    n = 'Map',
    o = 'Set',
    a = 'Array',
    s = { Map: n, Set: o, Array: a },
    c = '[object Object]',
    i = '[object Map]',
    u = '[object Set]',
    f = '[object Array]',
    l = '[object Function]',
    p = { [i]: n, [u]: o, [f]: a, [c]: 'Object' },
    d = ['push', 'pop', 'shift', 'splice', 'unshift', 'reverse', 'copyWithin', 'delete', 'fill'],
    y = ['set', 'clear', 'delete'],
    h = ['add', 'clear', 'delete'],
    m = ['splice', 'sort', 'unshift', 'shift'],
    v = [
      'concat',
      'copyWithin',
      'entries',
      'every',
      'fill',
      'filter',
      'find',
      'findIndex',
      'flat',
      'flatMap',
      'forEach',
      'includes',
      'indexOf',
      'join',
      'keys',
      'lastIndexOf',
      'map',
      'pop',
      'push',
      'reduce',
      'reduceRight',
      'reverse',
      'shift',
      'unshift',
      'slice',
      'some',
      'sort',
      'splice',
      'values',
      'valueOf',
    ],
    b = {
      [n]: ['clear', 'delete', 'entries', 'forEach', 'get', 'has', 'keys', 'set', 'values'],
      [o]: ['add', 'clear', 'delete', 'entries', 'forEach', 'has', 'keys', 'values'],
      [a]: v,
    },
    M = { [n]: ['clear', 'set', 'delete'], [o]: ['clear', 'add', 'delete'], [a]: v },
    P = { [n]: ['forEach', 'get'], [o]: ['forEach'], [a]: ['forEach', 'map'] },
    O = { value: 0, usablePrefix: 1 },
    g = { autoFreeze: !1, usePatches: !1, fastModeRange: 'array' },
    k = Object.prototype.toString;
  function j(e) {
    return k.call(e);
  }
  function x(...e) {
    return e;
  }
  function w(e) {
    return j(e) === c;
  }
  function E(e) {
    return j(e) === i;
  }
  function D(e) {
    return j(e) === u;
  }
  function T(e) {
    return j(e) === l;
  }
  function V(e) {
    const t = j(e);
    return ![c, f, i, u, l].includes(t);
  }
  function A(e) {
    return 'AsyncFunction' === e.constructor.name || 'function' == typeof e.then;
  }
  function _(e) {
    return 'undefined' != typeof Promise && e instanceof Promise;
  }
  function B(e) {
    var t = typeof e;
    return 'number' === t || ('string' === t && /^[0-9]*$/.test(e));
  }
  function S(e) {
    return 'symbol' == typeof e;
  }
  const F = { [f]: Array.prototype, [i]: Map.prototype, [u]: Set.prototype, [l]: Function.prototype };
  function z(e) {
    e.rootMeta.modified = !0;
    const t = (e) => {
      e && !e.modified && ((e.modified = !0), t(e.parentMeta));
    };
    t(e);
  }
  function I(e, r, n, o) {
    return (
      n
        ? (e[t] = r)
        : (!(function (e, t) {
            const r = j(e),
              n = F[r] || Object.prototype,
              o = Object.create(null);
            t && Object.assign(o, t), Object.setPrototypeOf(o, n), Object.setPrototypeOf(e, o);
          })(e, o),
          (e.__proto__[t] = r)),
      e
    );
  }
  function R(e, t) {
    const { finishDraft: r, ver: n, parentMeta: o = null, key: a, immutBase: s, compareVer: c } = t,
      i = ((u = j(e)), p[u]);
    var u;
    let f = [],
      l = 0,
      d = null;
    o &&
      ((d = o.copy),
      (l = (function (e) {
        const t = $(e);
        return t ? t.level + 1 : 1;
      })(d)),
      (f = (function (e, t) {
        const r = [t],
          n = C(e);
        if (n && n.level > 0) {
          const { keyPath: e } = n;
          return [...e, t];
        }
        return r;
      })(d, a)));
    const y = {
      rootMeta: null,
      parentMeta: o,
      parent: d,
      selfType: i,
      self: e,
      copy: null,
      key: a,
      keyPath: f,
      level: l,
      proxyVal: null,
      proxyItems: null,
      modified: !1,
      scopes: [],
      isImmutBase: s,
      isDel: !1,
      isFast: !1,
      isArrOrderChanged: !1,
      newNodeStats: {},
      linkCount: 1,
      finishDraft: r,
      ver: n,
      compareVer: c,
      revoke: x,
    };
    return (y.rootMeta = 0 === l ? y : o.rootMeta), y;
  }
  function N(e) {
    if (V(e)) return !1;
    const t = $(e);
    return !!t && !t.isImmutBase;
  }
  function C(e) {
    return e[t];
  }
  function $(e) {
    return (e && e[t]) || null;
  }
  function K(e, t) {
    const r = $(e),
      n = $(t);
    if (!r && !n) return !Object.is(e, t);
    const { self: o, modified: a, compareVer: s, ver: c, level: i } = r || { self: e, modified: !1, compareVer: !1, ver: '0', level: 0 },
      { self: u, modified: f, compareVer: l, ver: p, level: d } = n || { self: t, modified: !1, compareVer: !1, ver: '0', level: 0 };
    return o !== u || !((!s && !l) || (0 !== i && 0 !== d) || c === p) || a || f;
  }
  function U(e) {
    const t = (e) => {
      if (V(e)) return e;
      let r = e;
      if (
        (Array.isArray(e) &&
          ((r = e.slice()),
          r.forEach((e, n) => {
            r[n] = t(e);
          })),
        D(e))
      ) {
        const n = Array.from(e);
        n.forEach((e, r) => {
          n[r] = t(e);
        }),
          (r = new Set(n));
      }
      return (
        E(e) &&
          ((r = new Map(e)),
          r.forEach((e, n) => {
            r.set(n, t(e));
          })),
        w(e) &&
          ((r = {}),
          Object.keys(e).forEach((n) => {
            r[n] = t(e[n]);
          })),
        r
      );
    };
    return t(e);
  }
  function W(e, t, r) {
    const { extraProps: n } = r,
      { copy: o, fast: s } = (function (e, t) {
        const { parentType: r, fastModeRange: n } = t;
        if (Array.isArray(e)) return { copy: e.slice(), fast: !1 };
        const o = ('array' === n && r === a) || 'all' === n;
        let s = e;
        return e && w(e) && (s = Object.assign({}, e)), E(e) && (s = new Map(e)), D(e) && (s = new Set(e)), { copy: s, fast: o };
      })(e, r);
    return I(o, t, s, n), { copy: o, fast: s };
  }
  function G(e) {
    const { self: r, copy: s, modified: c } = e;
    let i = r;
    return (
      s && c && (i = e.copy),
      (function (e) {
        e.scopes.forEach((e) => {
          const { modified: r, copy: s, parentMeta: c, key: i, self: u, revoke: f, proxyVal: l, isDel: p, isFast: d } = e;
          if (!s) return f();
          if ((d ? delete s[t] : delete s.__proto__[t], !c)) return f();
          const y = r ? s : u,
            h = c.copy,
            m = c.selfType;
          return m === n
            ? (h.set(i, y), f())
            : m === o
            ? (h.delete(l), h.add(y), f())
            : m === a
            ? ((function (e, t, r) {
                const { copy: n, isArrOrderChanged: o } = e,
                  { targetNode: a, key: s } = r;
                if (o) {
                  const e = n.findIndex((e) => e === t.copy);
                  e >= 0 && (n[e] = a);
                } else n[s] = a;
              })(c, e, { targetNode: y, key: i }),
              f())
            : !0 !== p
            ? ((h[i] = y), f())
            : void 0;
        }),
          (e.scopes.length = 0);
      })(e),
      i
    );
  }
  function J(e) {
    e.rootMeta.scopes.push(e);
  }
  function L(e, t) {
    const {
        finishDraft: r = x,
        ver: n,
        traps: o,
        parentType: a,
        parentMeta: s,
        key: c,
        fastModeRange: i,
        immutBase: u,
        extraProps: f,
        compareVer: l = !1,
      } = t,
      p = R(e, { finishDraft: r, ver: n, parentMeta: s, key: c, immutBase: u, compareVer: l }),
      { copy: d, fast: y } = W(e, p, { parentType: a, fastModeRange: i, extraProps: f });
    if (((p.copy = d), (p.isFast = y), u)) {
      const e = new Proxy(d, o);
      (p.proxyVal = e), (p.revoke = x);
    } else {
      const e = Proxy.revocable(d, o);
      (p.proxyVal = e.proxy), (p.revoke = e.revoke);
    }
    return p;
  }
  function X(e, t) {
    const {
      key: r,
      parentMeta: s,
      ver: c,
      traps: i,
      parent: u,
      patches: f,
      inversePatches: l,
      usePatches: p,
      parentType: d,
      fastModeRange: y,
      immutBase: h,
      readOnly: m,
      extraProps: v,
      compareVer: b,
    } = t;
    let M = e;
    if (m && s && !T(e)) {
      const { copy: e, self: t } = s,
        n = t[r];
      (e[r] = n), (M = n);
    }
    const O = (e, t) => {
      const r = t || '';
      if (V(e) || !e) return e;
      if (!s) throw new Error('[[ createMeta ]]: meta should not be null');
      if (!T(e)) {
        if (s.newNodeStats[r]) return e;
        let t = C(e);
        return (
          t ||
            ((t = L(e, {
              key: r,
              parentMeta: s,
              parentType: d,
              ver: c,
              traps: i,
              fastModeRange: y,
              immutBase: h,
              readOnly: m,
              extraProps: v,
              compareVer: b,
            })),
            J(t),
            (u[r] = t.copy)),
          t.proxyVal
        );
      }
      if (
        !(function (e, t) {
          return e === a || (P[e] || []).includes(t);
        })(d, r)
      )
        return e;
      if (s.proxyItems) return e;
      let M = [];
      if (d === o) {
        const e = new Set();
        u.forEach((t) => e.add(O(t))),
          H(e, s, { dataType: o, patches: f, inversePatches: l, usePatches: p }),
          (M = I(e, s, y, v)),
          (s.copy = M);
      } else if (d === n) {
        const e = new Map();
        u.forEach((t, r) => e.set(r, O(t, r))),
          H(e, s, { dataType: n, patches: f, inversePatches: l, usePatches: p }),
          (M = I(e, s, y, v)),
          (s.copy = M);
      } else d === a && 'sort' !== r && ((s.copy = s.copy || u.slice()), (M = s.proxyVal));
      return (s.proxyItems = M), e;
    };
    return O(M, r);
  }
  function q(e) {
    if (!w(e)) return e;
    const t = C(e);
    return t ? t.copy : e;
  }
  function H(e, t, r) {
    const { dataType: a } = r,
      s = e.delete.bind(e),
      c = e.clear.bind(e);
    if (
      ((e.delete = function (...e) {
        return z(t), s(...e);
      }),
      (e.clear = function (...e) {
        return z(t), c(...e);
      }),
      a === o)
    ) {
      const n = e.add.bind(e);
      e.add = function (...e) {
        return z(t), Object.assign({ meta: t }, r), n(...e);
      };
    }
    if (a === n) {
      const n = e.set.bind(e);
      e.set = function (...e) {
        return z(t), Object.assign({ meta: t }, r), n(...e);
      };
    }
  }
  function Q(e, t) {
    const { op: r, key: s, value: c, calledBy: i, parentType: u, parentMeta: f } = t,
      l = q(c);
    if (!f) return void (e[s] = l);
    const { self: p, copy: v } = f;
    !(function (e) {
      const { calledBy: t, parentMeta: r, op: s, parentType: c } = e;
      (['deleteProperty', 'set'].includes(t) ||
        ('get' === t && ((c === o && h.includes(s)) || (c === a && d.includes(s)) || (c === n && y.includes(s))))) &&
        z(r);
    })({ calledBy: i, parentMeta: f, op: r, key: s, parentType: u });
    const M = b[u] || [];
    if (T(c) && M.includes(r))
      return 'slice' === r
        ? p.slice
        : (m.includes(r) && (f.isArrOrderChanged = !0), v ? (u === o || u === n ? v[r].bind(v) : v[r]) : p[r].bind(p));
    if (!v) return l;
    const P = v[s],
      O = () => {
        const e = $(P);
        e && (e.isDel = !0);
      };
    if ('deleteProperty' === i) {
      const e = $(c);
      return e ? (e.isDel = !0) : O(), void delete v[s];
    }
    v[s] || V(l) || (f.newNodeStats[s] = !0),
      (v[s] = l),
      O(),
      (() => {
        const e = $(c);
        e &&
          e.isDel &&
          ((e.isDel = !1),
          (e.key = s),
          (e.keyPath = f.keyPath.concat([s])),
          (e.level = f.level + 1),
          (e.parent = f.copy),
          (e.parentMeta = f));
      })();
  }
  function Y(e) {
    if (V(e)) return e;
    if (Array.isArray(e) && e.length > 0) return e.forEach(Y), Object.freeze(e);
    if (D(e)) {
      const t = e;
      (t.add = () => t), (t.delete = () => !1), (t.clear = x);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    if (E(e)) {
      const t = e;
      (t.set = () => t), (t.delete = () => !1), (t.clear = x);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    return (
      Object.getOwnPropertyNames(e).forEach((t) => {
        Y(e[t]);
      }),
      Object.freeze(e)
    );
  }
  const Z = ['length', 'constructor', 'asymmetricMatch', 'nodeType', 'size'],
    ee = [a, o, n];
  function te() {
    return console.error('can not mutate state at readOnly mode!'), !0;
  }
  function re(e) {
    var n, o, c, i, u;
    const f = e || {},
      l = f.onOperate,
      p = f.fastModeRange || g.fastModeRange,
      d = null !== (n = f[r]) && void 0 !== n && n,
      y = f.extraProps || null,
      h = null !== (o = f.readOnly) && void 0 !== o && o,
      m = null !== (c = f.compareVer) && void 0 !== c && c,
      v = null !== (i = f.autoFreeze) && void 0 !== i ? i : g.autoFreeze,
      P = null !== (u = f.usePatches) && void 0 !== u ? u : g.usePatches,
      k = (e, t, r) => {
        if (!r || !l) return;
        const { selfType: n, keyPath: o, self: a, copy: s } = r;
        let c = 'get' !== e,
          i = !1;
        if ((b[n] || []).includes(t)) {
          i = !0;
          c = (M[n] || []).includes(t);
        }
        l({ parentType: n, op: e, isBuiltInFnKey: i, isChange: c, key: t, keyPath: o, fullKeyPath: o.concat(t), value: s[t] || a[t] });
      },
      j = (() => {
        const e = (function () {
          O.value >= Number.MAX_SAFE_INTEGER ? ((O.value = 1), (O.usablePrefix += 1)) : (O.value += 1);
          const { value: e, usablePrefix: t } = O;
          return `${t}_${e}`;
        })();
        let r = !0;
        const n = [],
          o = [],
          c = {
            get: (r, i) => {
              let u = r[i];
              if ('toJSON' === i && Array.isArray(r)) return u;
              if ('__proto__' === i || i === t) return u;
              if (S(i)) return T(u) ? u.bind(r) : u;
              const f = C(r),
                l = null == f ? void 0 : f.selfType;
              return ee.includes(l) && Z.includes(i)
                ? f.copy[i]
                : ((u = X(u, {
                    key: i,
                    parentMeta: f,
                    parentType: l,
                    ver: e,
                    traps: c,
                    parent: r,
                    patches: n,
                    fastModeRange: p,
                    immutBase: d,
                    readOnly: h,
                    inversePatches: o,
                    usePatches: P,
                  })),
                  l === a && B(i)
                    ? (k('get', i, f), u)
                    : s[l]
                    ? ((u = Q(r, {
                        op: i,
                        key: i,
                        value: u,
                        metaVer: e,
                        calledBy: 'get',
                        patches: n,
                        inversePatches: o,
                        usePatches: P,
                        parentType: l,
                        parentMeta: f,
                      })),
                      k('get', i, f),
                      u)
                    : (k('get', i, f), u));
            },
            set: (t, n, o) => {
              let s = o;
              if (h) return te();
              if (N(o))
                if (((i = e), w((c = o)) && C(c).ver !== i)) r = !1;
                else if (((s = q(o)), s === t[n])) return !0;
              var c, i;
              const u = C(t);
              if (u && u.selfType === a) {
                if (u.copy && u.__callSet && B(n)) return (u.copy[n] = s), k('set', n, u), !0;
                u.__callSet = !0;
              }
              return Q(t, { parentMeta: u, key: n, value: s, metaVer: e, calledBy: 'set' }), k('set', n, u), !0;
            },
            deleteProperty: (t, r) => {
              if (h) return te();
              const n = C(t);
              return Q(t, { parentMeta: n, op: 'del', key: r, value: '', metaVer: e, calledBy: 'deleteProperty' }), k('del', r, n), !0;
            },
            apply: function (e, t, r) {
              return e.apply(t, r);
            },
          };
        return {
          createDraft: (t) => {
            if (V(t)) throw new Error('base state can not be primitive');
            let r = t;
            const n = C(t);
            if (n) {
              if (d && n.isImmutBase) return n.proxyVal;
              r = n.self;
            }
            const o = L(r, {
              key: '',
              ver: e,
              traps: c,
              finishDraft: j.finishDraft,
              immutBase: d,
              readOnly: h,
              extraProps: y,
              compareVer: m,
            });
            return J(o), o.proxyVal;
          },
          finishDraft: (e) => {
            const t = C(e);
            if (!t) throw new Error('rootMeta should not be null!');
            if (0 !== t.level) throw new Error('can not finish sub draft node!');
            if (t.isImmutBase) return e;
            let n = G(t);
            return v && r && (n = Y(n)), n;
          },
        };
      })();
    return j;
  }
  const ne = N,
    oe = K,
    ae = function (e, t, r = !0) {
      const n = r ? K : Object.is;
      return !((e, t) => {
        for (let r in e) if (!(r in t)) return !0;
        for (let r in t) if (n(e[r], t[r])) return !0;
        return !1;
      })(e, t);
    },
    se = {
      noop: x,
      isObject: w,
      isMap: E,
      isSet: D,
      isFn: T,
      isPrimitive: V,
      isPromiseFn: A,
      isPromiseResult: _,
      isSymbol: S,
      canBeNum: B,
      isDraft: ne,
      isDiff: oe,
      shallowCompare: ae,
      getDraftMeta: $,
    };
  function ce(e, t) {
    return re(t).createDraft(e);
  }
  function ie(e) {
    const t = $(e);
    let r = null;
    if ((t && (r = t.finishDraft), !r)) throw new Error('not a Limu draft!');
    return r(e);
  }
  function ue(e) {
    if (!T(e)) throw new Error('produce callback is not a function');
  }
  function fe(e, t, r) {
    ue(t);
    const n = ce(e, r),
      o = t(n);
    return (
      (function (e, t) {
        if (A(e) || _(t)) throw new Error('produce callback can not be a promise function or result');
      })(t, o),
      ie(n)
    );
  }
  const le = function (e, t, r) {
      if (!t || !T(t)) {
        const r = e,
          n = t;
        return ue(e), (e) => fe(e, r, n);
      }
      return fe(e, t, r);
    },
    pe = Y;
  const de = function (e) {
      const t = $(e);
      return t ? t.self : e;
    },
    ye = function (e) {
      const t = $(e);
      return t ? U(t.copy || t.self) : e;
    };
  (e.VER = '3.5.8'),
    (e.createDraft = ce),
    (e.current = ye),
    (e.deepCopy = function (e) {
      return U(e);
    }),
    (e.deepFreeze = pe),
    (e.finishDraft = ie),
    (e.getAutoFreeze = function () {
      return g.autoFreeze;
    }),
    (e.immut = function (e, t) {
      return re(Object.assign(Object.assign({}, t || {}), { readOnly: !0, [r]: !0 })).createDraft(e);
    }),
    (e.isDiff = oe),
    (e.isDraft = ne),
    (e.limuUtils = se),
    (e.original = de),
    (e.produce = le),
    (e.setAutoFreeze = function (e) {
      g.autoFreeze = e;
    }),
    (e.shallowCompare = ae),
    Object.defineProperty(e, '__esModule', { value: !0 });
});
