!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], t)
    : t(((e = 'undefined' != typeof globalThis ? globalThis : e || self).limu = {}));
})(this, function (e) {
  'use strict';
  const t = Symbol('M'),
    n = Symbol('V'),
    r = Symbol('IMMUT_BASE'),
    o = 'Map',
    a = 'Set',
    s = 'Array',
    c = { Map: o, Set: a, Array: s },
    i = '[object Object]',
    u = '[object Map]',
    l = '[object Set]',
    f = '[object Array]',
    p = '[object Function]',
    d = { [u]: o, [l]: a, [f]: s, [i]: 'Object' },
    y = ['push', 'pop', 'shift', 'splice', 'unshift', 'reverse', 'copyWithin', 'delete', 'fill'],
    h = ['set', 'clear', 'delete'],
    m = ['add', 'clear', 'delete'],
    v = ['splice', 'sort', 'unshift', 'shift'],
    M = [
      'concat',
      'copyWithin',
      'entries',
      'every',
      'fill',
      'filter',
      'find',
      'findIndex',
      'flat',
      'flatMap',
      'forEach',
      'includes',
      'indexOf',
      'join',
      'keys',
      'lastIndexOf',
      'map',
      'pop',
      'push',
      'reduce',
      'reduceRight',
      'reverse',
      'shift',
      'unshift',
      'slice',
      'some',
      'sort',
      'splice',
      'values',
      'valueOf',
    ],
    b = {
      [o]: ['clear', 'delete', 'entries', 'forEach', 'get', 'has', 'keys', 'set', 'values'],
      [a]: ['add', 'clear', 'delete', 'entries', 'forEach', 'has', 'keys', 'values'],
      [s]: M,
    },
    g = { [o]: ['clear', 'set', 'delete'], [a]: ['clear', 'add', 'delete'], [s]: M },
    O = { [o]: ['forEach', 'get'], [a]: ['forEach'], [s]: ['forEach', 'map'] },
    x = { value: 0, usablePrefix: 1 },
    P = { autoFreeze: !1, usePatches: !1, fastModeRange: 'array' },
    w = Object.prototype.toString,
    k = !!Reflect,
    j = Object.prototype.hasOwnProperty;
  function E(e) {
    return w.call(e);
  }
  function C(...e) {
    return e;
  }
  function V(e) {
    return E(e) === i;
  }
  function T(e) {
    return E(e) === u;
  }
  function A(e) {
    return E(e) === l;
  }
  function _(e) {
    return E(e) === p;
  }
  function S(e) {
    const t = E(e);
    return ![i, f, u, l, p].includes(t);
  }
  function B(e) {
    return 'AsyncFunction' === e.constructor.name || 'function' == typeof e.then;
  }
  function D(e) {
    return 'undefined' != typeof Promise && e instanceof Promise;
  }
  function F(e) {
    var t = typeof e;
    return 'number' === t || ('string' === t && /^[0-9]*$/.test(e));
  }
  function N(e) {
    return 'symbol' == typeof e;
  }
  const z = { [f]: Array.prototype, [u]: Map.prototype, [l]: Set.prototype, [p]: Function.prototype };
  const R = new Map();
  function I(e) {
    e.rootMeta.modified = !0;
    const t = (e) => {
      e && !e.modified && ((e.modified = !0), t(e.parentMeta));
    };
    t(e);
  }
  function W(e, n, r) {
    if (r.apiCtx.debug) {
      const { fast: o } = r;
      o
        ? (e[t] = n)
        : (!(function (e) {
            const t = E(e),
              n = z[t] || Object.prototype,
              r = Object.create(null);
            Object.setPrototypeOf(r, n), Object.setPrototypeOf(e, r);
          })(e),
          (e.__proto__[t] = n));
    }
    return e;
  }
  function $(e, t) {
    const { ver: n, parentMeta: r = null, key: o, immutBase: a, compareVer: s, apiCtx: c } = t,
      i = ((u = E(e)), d[u]);
    var u;
    let l = [],
      f = 0,
      p = null;
    r &&
      ((p = r.copy),
      (f = (function (e, t) {
        const n = G(e, t);
        return n ? n.level + 1 : 1;
      })(p, c)),
      (l = (function (e, t, n) {
        const r = [t],
          o = U(e, n);
        if (o && o.level > 0) {
          const { keyPath: e } = o;
          return [...e, t];
        }
        return r;
      })(p, o, c)));
    const y = {
      rootMeta: null,
      parentMeta: r,
      parent: p,
      selfType: i,
      self: e,
      copy: null,
      key: o,
      keyPath: l,
      level: f,
      proxyVal: null,
      proxyItems: null,
      modified: !1,
      scopes: [],
      isImmutBase: a,
      isDel: !1,
      isFast: !1,
      isArrOrderChanged: !1,
      newNodeStats: {},
      newNodeMap: new Map(),
      newNodes: [],
      linkCount: 1,
      ver: n,
      compareVer: s,
      revoke: C,
    };
    return (y.rootMeta = 0 === f ? y : r.rootMeta), y;
  }
  function K(e) {
    const t = X(e);
    return !!t && !t.isImmutBase;
  }
  function U(e, t) {
    return t.metaMap.get(e);
  }
  function G(e, t) {
    let n = t || L(e);
    return (null == n ? void 0 : n.metaMap.get(e)) || null;
  }
  function J(e) {
    return (e && e[n]) || '';
  }
  function L(e) {
    const t = J(e);
    return R.get(t) || null;
  }
  function X(e) {
    const t = L(e);
    return (t && t.metaMap.get(e)) || null;
  }
  function q(e, t) {
    const n = X(e),
      r = X(t);
    if (!n && !r) return !Object.is(e, t);
    const { self: o, modified: a, compareVer: s, ver: c, level: i } = n || { self: e, modified: !1, compareVer: !1, ver: '0', level: 0 },
      { self: u, modified: l, compareVer: f, ver: p, level: d } = r || { self: t, modified: !1, compareVer: !1, ver: '0', level: 0 };
    return o !== u || !((!s && !f) || (0 !== i && 0 !== d) || c === p) || a || l;
  }
  function H(e) {
    const t = (e) => {
      if (S(e)) return e;
      let n = e;
      if (
        (Array.isArray(e) &&
          ((n = e.slice()),
          n.forEach((e, r) => {
            n[r] = t(e);
          })),
        A(e))
      ) {
        const r = Array.from(e);
        r.forEach((e, n) => {
          r[n] = t(e);
        }),
          (n = new Set(r));
      }
      return (
        T(e) &&
          ((n = new Map(e)),
          n.forEach((e, r) => {
            n.set(r, t(e));
          })),
        V(e) &&
          ((n = {}),
          Object.keys(e).forEach((r) => {
            n[r] = t(e[r]);
          })),
        n
      );
    };
    return t(e);
  }
  function Q(e, t, n) {
    const { apiCtx: r } = n,
      { copy: o, fast: a } = (function (e, t) {
        const { parentType: n, fastModeRange: r } = t;
        if (Array.isArray(e)) return { copy: e.slice(), fast: !1 };
        const o = ('array' === r && n === s) || 'all' === r;
        let a = e;
        return e && V(e) && (a = Object.assign({}, e)), T(e) && (a = new Map(e)), A(e) && (a = new Set(e)), { copy: a, fast: o };
      })(e, n);
    return W(o, t, { apiCtx: r, fast: a }), { copy: o, fast: a };
  }
  function Y(e, n) {
    const { debug: r } = n,
      c = new Map();
    e.newNodeMap.forEach((e) => {
      const { node: t, parent: r, key: o } = e,
        a = c.get(t);
      if (a) return void (r[o] = a);
      const s = e;
      !(function (e, t, n, r) {
        const o = (e, t, n) => {
          S(e) ||
            (r(e, t, n),
            Array.isArray(e) &&
              e.forEach((t, n) => {
                o(t, e, n);
              }),
            T(e) &&
              e.forEach((t, n) => {
                o(t, e, n);
              }),
            V(e) &&
              Object.keys(e).forEach((t) => {
                o(e[t], e, t);
              }));
        };
        o(e, t, n);
      })(t, r, o, (e, t, r) => {
        const o = G(e, n);
        if (o) {
          const { modified: e, copy: n, self: a } = o,
            s = e ? n : a;
          t[r] = s;
        }
      }),
        (s.target = r[o]),
        c.set(t, s.target);
    }),
      e.scopes.forEach((e) => {
        const { modified: n, copy: c, parentMeta: i, key: u, self: l, revoke: f, proxyVal: p, isDel: d, isFast: y } = e;
        if (!c) return f();
        if ((r && (y ? delete c[t] : delete c.__proto__[t]), !i)) return f();
        const h = n ? c : l,
          m = i.copy,
          v = i.selfType;
        return v === o
          ? (m.set(u, h), f())
          : v === a
          ? (m.delete(p), m.add(h), f())
          : v === s
          ? ((function (e, t, n) {
              const { copy: r, isArrOrderChanged: o } = e,
                { targetNode: a, key: s } = n;
              if (o) {
                const e = r.findIndex((e) => e === t.copy);
                e >= 0 && (r[e] = a);
              } else r[s] = a;
            })(i, e, { targetNode: h, key: u }),
            f())
          : !0 !== d
          ? ((m[u] = h), f())
          : void 0;
      }),
      (e.scopes.length = 0);
  }
  function Z(e) {
    e.rootMeta.scopes.push(e);
  }
  function ee(e, t) {
    const { traps: n, parentType: r, fastModeRange: o, immutBase: a, apiCtx: s } = t,
      c = $(e, t),
      { copy: i, fast: u } = Q(e, c, { parentType: r, fastModeRange: o, apiCtx: s });
    if (((c.copy = i), (c.isFast = u), a)) {
      const e = new Proxy(i, n);
      (c.proxyVal = e), (c.revoke = C);
    } else {
      const e = Proxy.revocable(i, n);
      (c.proxyVal = e.proxy), (c.revoke = e.revoke);
    }
    return s.metaMap.set(i, c), s.metaMap.set(c.proxyVal, c), c;
  }
  function te(e, t) {
    const {
      key: n,
      parentMeta: r,
      ver: c,
      traps: i,
      parent: u,
      patches: l,
      inversePatches: f,
      usePatches: p,
      parentType: d,
      fastModeRange: y,
      immutBase: h,
      readOnly: m,
      compareVer: v,
      apiCtx: M,
    } = t;
    let b = e;
    if (m && r && !_(e)) {
      const { copy: e, self: t } = r,
        o = t[n];
      (e[n] = o), (b = o);
    }
    const g = (e, t) => {
      const n = t || '';
      if (S(e) || !e) return e;
      if (!r) throw new Error('[[ createMeta ]]: meta should not be null');
      if (!_(e)) {
        if (r.newNodeStats[n]) return e;
        let t = U(e, M);
        return (
          t ||
            ((t = ee(e, {
              key: n,
              parentMeta: r,
              parentType: d,
              ver: c,
              traps: i,
              fastModeRange: y,
              immutBase: h,
              readOnly: m,
              compareVer: v,
              apiCtx: M,
            })),
            Z(t),
            (u[n] = t.copy)),
          t.proxyVal
        );
      }
      if (
        !(function (e, t) {
          return e === s || (O[e] || []).includes(t);
        })(d, n)
      )
        return e;
      if (r.proxyItems) return e;
      let b = [];
      if (d === a) {
        const e = new Set();
        u.forEach((t) => e.add(g(t))),
          re(e, r, { dataType: a, patches: l, inversePatches: f, usePatches: p }),
          (b = W(e, r, { fast: y, apiCtx: M })),
          (r.copy = b);
      } else if (d === o) {
        const e = new Map();
        u.forEach((t, n) => e.set(n, g(t, n))),
          re(e, r, { dataType: o, patches: l, inversePatches: f, usePatches: p }),
          (b = W(e, r, { fast: y, apiCtx: M })),
          (r.copy = b);
      } else d === s && 'sort' !== n && ((r.copy = r.copy || u.slice()), (b = r.proxyVal));
      return (r.proxyItems = b), e;
    };
    return g(b, n);
  }
  function ne(e, t) {
    if (!V(e)) return e;
    const n = U(e, t);
    return n ? n.copy : e;
  }
  function re(e, t, n) {
    const { dataType: r } = n,
      s = e.delete.bind(e),
      c = e.clear.bind(e);
    if (
      ((e.delete = function (...e) {
        return I(t), s(...e);
      }),
      (e.clear = function (...e) {
        return I(t), c(...e);
      }),
      r === a)
    ) {
      const r = e.add.bind(e);
      e.add = function (...e) {
        return I(t), Object.assign({ meta: t }, n), r(...e);
      };
    }
    if (r === o) {
      const r = e.set.bind(e);
      e.set = function (...e) {
        return I(t), Object.assign({ meta: t }, n), r(...e);
      };
    }
  }
  function oe(e, t) {
    const n = e.keyPath.slice();
    n.push(t);
    return n.join('|');
  }
  function ae(e, t) {
    const { op: n, key: r, value: c, calledBy: i, parentType: u, parentMeta: l, apiCtx: f } = t,
      p = ne(c, f);
    if (!l) return void (e[r] = p);
    const { self: d, copy: M, rootMeta: g } = l;
    !(function (e) {
      const { calledBy: t, parentMeta: n, op: r, parentType: c } = e;
      (['deleteProperty', 'set'].includes(t) ||
        ('get' === t && ((c === a && m.includes(r)) || (c === s && y.includes(r)) || (c === o && h.includes(r))))) &&
        I(n);
    })({ calledBy: i, parentMeta: l, op: n, key: r, parentType: u });
    const O = b[u] || [];
    if (_(c) && O.includes(n))
      return 'slice' === n
        ? d.slice
        : (v.includes(n) && (l.isArrOrderChanged = !0), M ? (u === a || u === o ? M[n].bind(M) : M[n]) : d[n].bind(d));
    if (!M) return p;
    const x = M[r],
      P = () => {
        const e = G(x, f);
        e && (e.isDel = !0);
      };
    if ('deleteProperty' === i) {
      const e = G(c, f);
      e ? (e.isDel = !0) : P();
      return S(M[r]) || g.newNodeMap.delete(oe(l, r)), void delete M[r];
    }
    S(p) || ((l.newNodeStats[r] = !0), g.newNodeMap.set(oe(l, r), { parent: M, node: p, key: r, target: null })),
      (M[r] = p),
      P(),
      (() => {
        const e = G(c, f);
        e &&
          e.isDel &&
          ((e.isDel = !1),
          (e.key = r),
          (e.keyPath = l.keyPath.concat([r])),
          (e.level = l.level + 1),
          (e.parent = l.copy),
          (e.parentMeta = l));
      })();
  }
  function se(e) {
    if (S(e)) return e;
    if (Array.isArray(e) && e.length > 0) return e.forEach(se), Object.freeze(e);
    if (A(e)) {
      const t = e;
      (t.add = () => t), (t.delete = () => !1), (t.clear = C);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    if (T(e)) {
      const t = e;
      (t.set = () => t), (t.delete = () => !1), (t.clear = C);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    return (
      Object.getOwnPropertyNames(e).forEach((t) => {
        se(e[t]);
      }),
      Object.freeze(e)
    );
  }
  const ce = ['length', 'constructor', 'asymmetricMatch', 'nodeType', 'size'],
    ie = [s, a, o],
    ue = new Map();
  function le(e) {
    var o, a, i, u, l, f;
    const p = e || {},
      d = p.onOperate,
      y = p.fastModeRange || P.fastModeRange,
      h = null !== (o = p[r]) && void 0 !== o && o,
      m = null !== (a = p.readOnly) && void 0 !== a && a,
      v = p.disableWarn,
      M = null !== (i = p.compareVer) && void 0 !== i && i,
      O = null !== (u = p.debug) && void 0 !== u && u,
      w = null !== (l = p.autoFreeze) && void 0 !== l ? l : P.autoFreeze,
      E = null !== (f = p.usePatches) && void 0 !== f ? f : P.usePatches,
      C = (function () {
        x.value >= Number.MAX_SAFE_INTEGER ? ((x.value = 1), (x.usablePrefix += 1)) : (x.value += 1);
        const { value: e, usablePrefix: t } = x;
        return `${t}_${e}`;
      })(),
      T = { metaMap: new Map(), debug: O, metaVer: C };
    R.set(C, T);
    const A = () => (v || console.warn('can not mutate state at readOnly mode!'), !0),
      B = (e, t, n) => {
        const { parentMeta: r } = n;
        if (!r || !d) return;
        const { selfType: o, keyPath: a, self: s, copy: c } = r;
        let i = null,
          u = !1,
          l = !1;
        if (void 0 !== n.isChange) (u = n.isChange), (i = n.value);
        else {
          if (((u = 'get' !== e), (b[o] || []).includes(t))) {
            l = !0;
            u = (g[o] || []).includes(t);
          }
          i = c[t] || s[t];
        }
        d({ parentType: o, op: e, isBuiltInFnKey: l, isChange: u, key: t, keyPath: a, fullKeyPath: a.concat(t), value: i });
      },
      D = (() => {
        let e = !0;
        const r = [],
          o = [],
          a = {
            get: (e, i) => {
              if (n === i) return C;
              let u = e[i];
              if (
                'toJSON' === i &&
                !(function (e, t) {
                  return k ? Reflect.has(e, t) : j.call(e, t);
                })(e, i)
              )
                return u;
              if ('__proto__' === i || i === t) return u;
              if (N(i)) return _(u) ? u.bind(e) : u;
              const l = U(e, T),
                f = null == l ? void 0 : l.selfType;
              return ie.includes(f) && ce.includes(i)
                ? l.copy[i]
                : ((u = te(u, {
                    key: i,
                    parentMeta: l,
                    parentType: f,
                    ver: C,
                    traps: a,
                    parent: e,
                    patches: r,
                    fastModeRange: y,
                    immutBase: h,
                    readOnly: m,
                    inversePatches: o,
                    usePatches: E,
                    apiCtx: T,
                  })),
                  f === s && F(i)
                    ? (B('get', i, { parentMeta: l }), u)
                    : c[f]
                    ? ((u = ae(e, {
                        op: i,
                        key: i,
                        value: u,
                        metaVer: C,
                        calledBy: 'get',
                        patches: r,
                        inversePatches: o,
                        usePatches: E,
                        parentType: f,
                        parentMeta: l,
                        apiCtx: T,
                      })),
                      B('get', i, { parentMeta: l }),
                      u)
                    : (B('get', i, { parentMeta: l }), u));
            },
            set: (t, n, r) => {
              let o = r;
              const a = U(t, T);
              if (K(r))
                if (((i = C), V((c = r)) && J(c) !== i)) e = !1;
                else if (((o = ne(r, T)), o === t[n])) return !0;
              var c, i;
              if (m) return B('set', n, { parentMeta: a, isChange: !1, value: o }), A();
              if (a && a.selfType === s) {
                if (a.copy && a.__callSet && F(n)) return (a.copy[n] = o), B('set', n, { parentMeta: a }), !0;
                a.__callSet = !0;
              }
              return ae(t, { parentMeta: a, key: n, value: o, metaVer: C, calledBy: 'set', apiCtx: T }), B('set', n, { parentMeta: a }), !0;
            },
            deleteProperty: (e, t) => {
              const n = U(e, T);
              return m
                ? (B('del', t, { parentMeta: n, isChange: !1 }), A())
                : (ae(e, { parentMeta: n, op: 'del', key: t, value: '', metaVer: C, calledBy: 'deleteProperty', apiCtx: T }),
                  B('del', t, { parentMeta: n }),
                  !0);
            },
            apply: function (e, t, n) {
              return e.apply(t, n);
            },
          };
        return {
          createDraft: (e) => {
            if (S(e)) throw new Error('base state can not be primitive');
            let t = e;
            const n = U(e, T);
            if (n) {
              if (h && n.isImmutBase) return n.proxyVal;
              t = n.self;
            }
            const r = ee(t, { key: '', ver: C, traps: a, immutBase: h, readOnly: m, compareVer: M, apiCtx: T });
            return Z(r), ue.set(r.proxyVal, D.finishDraft), r.proxyVal;
          },
          finishDraft: (t) => {
            const n = U(t, T);
            if (!n) throw new Error('rootMeta should not be null!');
            if (0 !== n.level) throw new Error('can not finish sub draft node!');
            if (n.isImmutBase) return t;
            let r = (function (e, t) {
              const { self: n, copy: r, modified: o } = e;
              let a = n;
              return r && o && (a = e.copy), Y(e, t), a;
            })(n, T);
            return w && e && (r = se(r)), T.metaMap.clear(), r;
          },
        };
      })();
    return D;
  }
  const fe = K,
    pe = q,
    de = function (e, t, n = !0) {
      const r = n ? q : Object.is;
      return !((e, t) => {
        for (let n in e) if (!(n in t)) return !0;
        for (let n in t) if (r(e[n], t[n])) return !0;
        return !1;
      })(e, t);
    },
    ye = {
      noop: C,
      isObject: V,
      isMap: T,
      isSet: A,
      isFn: _,
      isPrimitive: S,
      isPromiseFn: B,
      isPromiseResult: D,
      isSymbol: N,
      canBeNum: F,
      isDraft: fe,
      isDiff: pe,
      shallowCompare: de,
      getDraftMeta: G,
    };
  function he(e, t) {
    return le(t).createDraft(e);
  }
  function me(e) {
    const t = ue.get(e);
    if (!t) throw new Error('Not a Limu root draft or draft has been finished!');
    return ue.delete(e), t(e);
  }
  function ve(e) {
    if (!_(e)) throw new Error('produce callback is not a function');
  }
  function Me(e, t, n) {
    ve(t);
    const r = he(e, n),
      o = t(r);
    return (
      (function (e, t) {
        if (B(e) || D(t)) throw new Error('produce callback can not be a promise function or result');
      })(t, o),
      me(r)
    );
  }
  const be = function (e, t, n) {
      if (!t || !_(t)) {
        const n = e,
          r = t;
        return ve(e), (e) => Me(e, n, r);
      }
      return Me(e, t, n);
    },
    ge = se;
  const Oe = function (e) {
      const t = G(e);
      return t ? t.self : e;
    },
    xe = function (e) {
      const t = G(e);
      return t ? H(t.copy || t.self) : e;
    };
  (e.VER = '3.7.0'),
    (e.createDraft = he),
    (e.current = xe),
    (e.deepCopy = function (e) {
      return H(e);
    }),
    (e.deepFreeze = ge),
    (e.finishDraft = me),
    (e.getAutoFreeze = function () {
      return P.autoFreeze;
    }),
    (e.immut = function (e, t) {
      return le(Object.assign(Object.assign({}, t || {}), { readOnly: !0, [r]: !0 })).createDraft(e);
    }),
    (e.isDiff = pe),
    (e.isDraft = fe),
    (e.limuUtils = ye),
    (e.original = Oe),
    (e.produce = be),
    (e.setAutoFreeze = function (e) {
      P.autoFreeze = e;
    }),
    (e.shallowCompare = de),
    Object.defineProperty(e, '__esModule', { value: !0 });
});
