!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], t)
    : t(((e = 'undefined' != typeof globalThis ? globalThis : e || self).limu = {}));
})(this, function (e) {
  'use strict';
  const t = Symbol('M'),
    r = Symbol('IMMUT_BASE'),
    n = 'Map',
    o = 'Set',
    a = 'Array',
    s = { Map: n, Set: o, Array: a },
    c = '[object Object]',
    i = '[object Map]',
    u = '[object Set]',
    l = '[object Array]',
    f = '[object Function]',
    p = { [i]: n, [u]: o, [l]: a, [c]: 'Object' },
    d = ['push', 'pop', 'shift', 'splice', 'unshift', 'reverse', 'copyWithin', 'delete', 'fill'],
    y = ['set', 'clear', 'delete'],
    h = ['add', 'clear', 'delete'],
    m = ['splice', 'sort', 'unshift', 'shift'],
    v = [
      'concat',
      'copyWithin',
      'entries',
      'every',
      'fill',
      'filter',
      'find',
      'findIndex',
      'flat',
      'flatMap',
      'forEach',
      'includes',
      'indexOf',
      'join',
      'keys',
      'lastIndexOf',
      'map',
      'pop',
      'push',
      'reduce',
      'reduceRight',
      'reverse',
      'shift',
      'unshift',
      'slice',
      'some',
      'sort',
      'splice',
      'values',
      'valueOf',
    ],
    b = {
      [n]: ['clear', 'delete', 'entries', 'forEach', 'get', 'has', 'keys', 'set', 'values'],
      [o]: ['add', 'clear', 'delete', 'entries', 'forEach', 'has', 'keys', 'values'],
      [a]: v,
    },
    M = { [n]: ['clear', 'set', 'delete'], [o]: ['clear', 'add', 'delete'], [a]: v },
    g = { [n]: ['forEach', 'get'], [o]: ['forEach'], [a]: ['forEach', 'map'] },
    P = { value: 0, usablePrefix: 1 },
    O = { autoFreeze: !1, usePatches: !1, fastModeRange: 'array' },
    k = Object.prototype.toString;
  function j(e) {
    return k.call(e);
  }
  function x(...e) {
    return e;
  }
  function w(e) {
    return j(e) === c;
  }
  function E(e) {
    return j(e) === i;
  }
  function D(e) {
    return j(e) === u;
  }
  function T(e) {
    return j(e) === f;
  }
  function V(e) {
    const t = j(e);
    return ![c, l, i, u, f].includes(t);
  }
  function A(e) {
    return 'AsyncFunction' === e.constructor.name || 'function' == typeof e.then;
  }
  function _(e) {
    return 'undefined' != typeof Promise && e instanceof Promise;
  }
  function B(e) {
    var t = typeof e;
    return 'number' === t || ('string' === t && /^[0-9]*$/.test(e));
  }
  function S(e) {
    return 'symbol' == typeof e;
  }
  const F = { [l]: Array.prototype, [i]: Map.prototype, [u]: Set.prototype, [f]: Function.prototype };
  function z(e) {
    e.rootMeta.modified = !0;
    const t = (e) => {
      e && !e.modified && ((e.modified = !0), t(e.parentMeta));
    };
    t(e);
  }
  function I(e, r, n, o) {
    return (
      n
        ? (e[t] = r)
        : (!(function (e, t) {
            const r = j(e),
              n = F[r] || Object.prototype,
              o = Object.create(null);
            t && Object.assign(o, t), Object.setPrototypeOf(o, n), Object.setPrototypeOf(e, o);
          })(e, o),
          (e.__proto__[t] = r)),
      e
    );
  }
  function R(e, t) {
    const { finishDraft: r, ver: n, parentMeta: o = null, key: a, immutBase: s, compareVer: c } = t,
      i = ((u = j(e)), p[u]);
    var u;
    let l = [],
      f = 0,
      d = null;
    o &&
      ((d = o.copy),
      (f = (function (e) {
        const t = W(e);
        return t ? t.level + 1 : 1;
      })(d)),
      (l = (function (e, t) {
        const r = [t],
          n = N(e);
        if (n && n.level > 0) {
          const { keyPath: e } = n;
          return [...e, t];
        }
        return r;
      })(d, a)));
    const y = {
      rootMeta: null,
      parentMeta: o,
      parent: d,
      selfType: i,
      self: e,
      copy: null,
      key: a,
      keyPath: l,
      level: f,
      proxyVal: null,
      proxyItems: null,
      modified: !1,
      scopes: [],
      isImmutBase: s,
      isDel: !1,
      isFast: !1,
      isArrOrderChanged: !1,
      newNodeStats: {},
      linkCount: 1,
      finishDraft: r,
      ver: n,
      compareVer: c,
      revoke: x,
    };
    return (y.rootMeta = 0 === f ? y : o.rootMeta), y;
  }
  function C(e) {
    if (V(e)) return !1;
    const t = W(e);
    return !!t && !t.isImmutBase;
  }
  function N(e) {
    return e[t];
  }
  function W(e) {
    return (e && e[t]) || null;
  }
  function $(e, t) {
    const r = W(e),
      n = W(t);
    if (!r && !n) return !Object.is(e, t);
    const { self: o, modified: a, compareVer: s, ver: c, level: i } = r || { self: e, modified: !1, compareVer: !1, ver: '0', level: 0 },
      { self: u, modified: l, compareVer: f, ver: p, level: d } = n || { self: t, modified: !1, compareVer: !1, ver: '0', level: 0 };
    return o !== u || !((!s && !f) || (0 !== i && 0 !== d) || c === p) || a || l;
  }
  function K(e) {
    const t = (e) => {
      if (V(e)) return e;
      let r = e;
      if (
        (Array.isArray(e) &&
          ((r = e.slice()),
          r.forEach((e, n) => {
            r[n] = t(e);
          })),
        D(e))
      ) {
        const n = Array.from(e);
        n.forEach((e, r) => {
          n[r] = t(e);
        }),
          (r = new Set(n));
      }
      return (
        E(e) &&
          ((r = new Map(e)),
          r.forEach((e, n) => {
            r.set(n, t(e));
          })),
        w(e) &&
          ((r = {}),
          Object.keys(e).forEach((n) => {
            r[n] = t(e[n]);
          })),
        r
      );
    };
    return t(e);
  }
  function U(e, t, r) {
    const { extraProps: n } = r,
      { copy: o, fast: s } = (function (e, t) {
        const { parentType: r, fastModeRange: n } = t;
        if (Array.isArray(e)) return { copy: e.slice(), fast: !1 };
        const o = ('array' === n && r === a) || 'all' === n;
        let s = e;
        return e && w(e) && (s = Object.assign({}, e)), E(e) && (s = new Map(e)), D(e) && (s = new Set(e)), { copy: s, fast: o };
      })(e, r);
    return I(o, t, s, n), { copy: o, fast: s };
  }
  function G(e) {
    const { self: r, copy: s, modified: c } = e;
    let i = r;
    return (
      s && c && (i = e.copy),
      (function (e) {
        e.scopes.forEach((e) => {
          const { modified: r, copy: s, parentMeta: c, key: i, self: u, revoke: l, proxyVal: f, isDel: p, isFast: d } = e;
          if (!s) return l();
          if ((d ? delete s[t] : delete s.__proto__[t], !c)) return l();
          const y = r ? s : u,
            h = c.copy,
            m = c.selfType;
          return m === n
            ? (h.set(i, y), l())
            : m === o
            ? (h.delete(f), h.add(y), l())
            : m === a
            ? ((function (e, t, r) {
                const { copy: n, isArrOrderChanged: o } = e,
                  { targetNode: a, key: s } = r;
                if (o) {
                  const e = n.findIndex((e) => e === t.copy);
                  e >= 0 && (n[e] = a);
                } else n[s] = a;
              })(c, e, { targetNode: y, key: i }),
              l())
            : !0 !== p
            ? ((h[i] = y), l())
            : void 0;
        }),
          (e.scopes.length = 0);
      })(e),
      i
    );
  }
  function J(e) {
    e.rootMeta.scopes.push(e);
  }
  function L(e, t) {
    const {
        finishDraft: r = x,
        ver: n,
        traps: o,
        parentType: a,
        parentMeta: s,
        key: c,
        fastModeRange: i,
        immutBase: u,
        extraProps: l,
        compareVer: f = !1,
      } = t,
      p = R(e, { finishDraft: r, ver: n, parentMeta: s, key: c, immutBase: u, compareVer: f }),
      { copy: d, fast: y } = U(e, p, { parentType: a, fastModeRange: i, extraProps: l });
    if (((p.copy = d), (p.isFast = y), u)) {
      const e = new Proxy(d, o);
      (p.proxyVal = e), (p.revoke = x);
    } else {
      const e = Proxy.revocable(d, o);
      (p.proxyVal = e.proxy), (p.revoke = e.revoke);
    }
    return p;
  }
  function X(e, t) {
    const {
      key: r,
      parentMeta: s,
      ver: c,
      traps: i,
      parent: u,
      patches: l,
      inversePatches: f,
      usePatches: p,
      parentType: d,
      fastModeRange: y,
      immutBase: h,
      readOnly: m,
      extraProps: v,
      compareVer: b,
    } = t;
    let M = e;
    if (m && s && !T(e)) {
      const { copy: e, self: t } = s,
        n = t[r];
      (e[r] = n), (M = n);
    }
    const P = (e, t) => {
      const r = t || '';
      if (V(e) || !e) return e;
      if (!s) throw new Error('[[ createMeta ]]: meta should not be null');
      if (!T(e)) {
        if (s.newNodeStats[r]) return e;
        let t = N(e);
        return (
          t ||
            ((t = L(e, {
              key: r,
              parentMeta: s,
              parentType: d,
              ver: c,
              traps: i,
              fastModeRange: y,
              immutBase: h,
              readOnly: m,
              extraProps: v,
              compareVer: b,
            })),
            J(t),
            (u[r] = t.copy)),
          t.proxyVal
        );
      }
      if (
        !(function (e, t) {
          return e === a || (g[e] || []).includes(t);
        })(d, r)
      )
        return e;
      if (s.proxyItems) return e;
      let M = [];
      if (d === o) {
        const e = new Set();
        u.forEach((t) => e.add(P(t))),
          H(e, s, { dataType: o, patches: l, inversePatches: f, usePatches: p }),
          (M = I(e, s, y, v)),
          (s.copy = M);
      } else if (d === n) {
        const e = new Map();
        u.forEach((t, r) => e.set(r, P(t, r))),
          H(e, s, { dataType: n, patches: l, inversePatches: f, usePatches: p }),
          (M = I(e, s, y, v)),
          (s.copy = M);
      } else d === a && 'sort' !== r && ((s.copy = s.copy || u.slice()), (M = s.proxyVal));
      return (s.proxyItems = M), e;
    };
    return P(M, r);
  }
  function q(e) {
    if (!w(e)) return e;
    const t = N(e);
    return t ? t.copy : e;
  }
  function H(e, t, r) {
    const { dataType: a } = r,
      s = e.delete.bind(e),
      c = e.clear.bind(e);
    if (
      ((e.delete = function (...e) {
        return z(t), s(...e);
      }),
      (e.clear = function (...e) {
        return z(t), c(...e);
      }),
      a === o)
    ) {
      const n = e.add.bind(e);
      e.add = function (...e) {
        return z(t), Object.assign({ meta: t }, r), n(...e);
      };
    }
    if (a === n) {
      const n = e.set.bind(e);
      e.set = function (...e) {
        return z(t), Object.assign({ meta: t }, r), n(...e);
      };
    }
  }
  function Q(e, t) {
    const { op: r, key: s, value: c, calledBy: i, parentType: u, parentMeta: l } = t,
      f = q(c);
    if (!l) return void (e[s] = f);
    const { self: p, copy: v } = l;
    !(function (e) {
      const { calledBy: t, parentMeta: r, op: s, parentType: c } = e;
      (['deleteProperty', 'set'].includes(t) ||
        ('get' === t && ((c === o && h.includes(s)) || (c === a && d.includes(s)) || (c === n && y.includes(s))))) &&
        z(r);
    })({ calledBy: i, parentMeta: l, op: r, key: s, parentType: u });
    const M = b[u] || [];
    if (T(c) && M.includes(r))
      return 'slice' === r
        ? p.slice
        : (m.includes(r) && (l.isArrOrderChanged = !0), v ? (u === o || u === n ? v[r].bind(v) : v[r]) : p[r].bind(p));
    if (!v) return f;
    const g = v[s],
      P = () => {
        const e = W(g);
        e && (e.isDel = !0);
      };
    if ('deleteProperty' === i) {
      const e = W(c);
      return e ? (e.isDel = !0) : P(), void delete v[s];
    }
    v[s] || V(f) || (l.newNodeStats[s] = !0),
      (v[s] = f),
      P(),
      (() => {
        const e = W(c);
        e &&
          e.isDel &&
          ((e.isDel = !1),
          (e.key = s),
          (e.keyPath = l.keyPath.concat([s])),
          (e.level = l.level + 1),
          (e.parent = l.copy),
          (e.parentMeta = l));
      })();
  }
  function Y(e) {
    if (V(e)) return e;
    if (Array.isArray(e) && e.length > 0) return e.forEach(Y), Object.freeze(e);
    if (D(e)) {
      const t = e;
      (t.add = () => t), (t.delete = () => !1), (t.clear = x);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    if (E(e)) {
      const t = e;
      (t.set = () => t), (t.delete = () => !1), (t.clear = x);
      for (const e of t.values()) Object.freeze(e);
      return Object.freeze(e);
    }
    return (
      Object.getOwnPropertyNames(e).forEach((t) => {
        Y(e[t]);
      }),
      Object.freeze(e)
    );
  }
  const Z = ['length', 'constructor', 'asymmetricMatch', 'nodeType', 'size'],
    ee = [a, o, n];
  function te(e) {
    var n, o, c, i, u;
    const l = e || {},
      f = l.onOperate,
      p = l.fastModeRange || O.fastModeRange,
      d = null !== (n = l[r]) && void 0 !== n && n,
      y = l.extraProps || null,
      h = null !== (o = l.readOnly) && void 0 !== o && o,
      m = l.disableWarn,
      v = null !== (c = l.compareVer) && void 0 !== c && c,
      g = null !== (i = l.autoFreeze) && void 0 !== i ? i : O.autoFreeze,
      k = null !== (u = l.usePatches) && void 0 !== u ? u : O.usePatches,
      j = () => (m || console.warn('can not mutate state at readOnly mode!'), !0),
      x = (e, t, r) => {
        const { parentMeta: n } = r;
        if (!n || !f) return;
        const { selfType: o, keyPath: a, self: s, copy: c } = n;
        let i = null,
          u = !1,
          l = !1;
        if (void 0 !== r.isChange) (u = r.isChange), (i = r.value);
        else {
          if (((u = 'get' !== e), (b[o] || []).includes(t))) {
            l = !0;
            u = (M[o] || []).includes(t);
          }
          i = c[t] || s[t];
        }
        f({ parentType: o, op: e, isBuiltInFnKey: l, isChange: u, key: t, keyPath: a, fullKeyPath: a.concat(t), value: i });
      },
      E = (() => {
        const e = (function () {
          P.value >= Number.MAX_SAFE_INTEGER ? ((P.value = 1), (P.usablePrefix += 1)) : (P.value += 1);
          const { value: e, usablePrefix: t } = P;
          return `${t}_${e}`;
        })();
        let r = !0;
        const n = [],
          o = [],
          c = {
            get: (r, i) => {
              let u = r[i];
              if ('toJSON' === i && Array.isArray(r)) return u;
              if ('__proto__' === i || i === t) return u;
              if (S(i)) return T(u) ? u.bind(r) : u;
              const l = N(r),
                f = null == l ? void 0 : l.selfType;
              return ee.includes(f) && Z.includes(i)
                ? l.copy[i]
                : ((u = X(u, {
                    key: i,
                    parentMeta: l,
                    parentType: f,
                    ver: e,
                    traps: c,
                    parent: r,
                    patches: n,
                    fastModeRange: p,
                    immutBase: d,
                    readOnly: h,
                    inversePatches: o,
                    usePatches: k,
                  })),
                  f === a && B(i)
                    ? (x('get', i, { parentMeta: l }), u)
                    : s[f]
                    ? ((u = Q(r, {
                        op: i,
                        key: i,
                        value: u,
                        metaVer: e,
                        calledBy: 'get',
                        patches: n,
                        inversePatches: o,
                        usePatches: k,
                        parentType: f,
                        parentMeta: l,
                      })),
                      x('get', i, { parentMeta: l }),
                      u)
                    : (x('get', i, { parentMeta: l }), u));
            },
            set: (t, n, o) => {
              let s = o;
              const c = N(t);
              if (C(o))
                if (((u = e), w((i = o)) && N(i).ver !== u)) r = !1;
                else if (((s = q(o)), s === t[n])) return !0;
              var i, u;
              if (h) return x('set', n, { parentMeta: c, isChange: !1, value: s }), j();
              if (c && c.selfType === a) {
                if (c.copy && c.__callSet && B(n)) return (c.copy[n] = s), x('set', n, { parentMeta: c }), !0;
                c.__callSet = !0;
              }
              return Q(t, { parentMeta: c, key: n, value: s, metaVer: e, calledBy: 'set' }), x('set', n, { parentMeta: c }), !0;
            },
            deleteProperty: (t, r) => {
              const n = N(t);
              return h
                ? (x('del', r, { parentMeta: n, isChange: !1 }), j())
                : (Q(t, { parentMeta: n, op: 'del', key: r, value: '', metaVer: e, calledBy: 'deleteProperty' }),
                  x('del', r, { parentMeta: n }),
                  !0);
            },
            apply: function (e, t, r) {
              return e.apply(t, r);
            },
          };
        return {
          createDraft: (t) => {
            if (V(t)) throw new Error('base state can not be primitive');
            let r = t;
            const n = N(t);
            if (n) {
              if (d && n.isImmutBase) return n.proxyVal;
              r = n.self;
            }
            const o = L(r, {
              key: '',
              ver: e,
              traps: c,
              finishDraft: E.finishDraft,
              immutBase: d,
              readOnly: h,
              extraProps: y,
              compareVer: v,
            });
            return J(o), o.proxyVal;
          },
          finishDraft: (e) => {
            const t = N(e);
            if (!t) throw new Error('rootMeta should not be null!');
            if (0 !== t.level) throw new Error('can not finish sub draft node!');
            if (t.isImmutBase) return e;
            let n = G(t);
            return g && r && (n = Y(n)), n;
          },
        };
      })();
    return E;
  }
  const re = C,
    ne = $,
    oe = function (e, t, r = !0) {
      const n = r ? $ : Object.is;
      return !((e, t) => {
        for (let r in e) if (!(r in t)) return !0;
        for (let r in t) if (n(e[r], t[r])) return !0;
        return !1;
      })(e, t);
    },
    ae = {
      noop: x,
      isObject: w,
      isMap: E,
      isSet: D,
      isFn: T,
      isPrimitive: V,
      isPromiseFn: A,
      isPromiseResult: _,
      isSymbol: S,
      canBeNum: B,
      isDraft: re,
      isDiff: ne,
      shallowCompare: oe,
      getDraftMeta: W,
    };
  function se(e, t) {
    return te(t).createDraft(e);
  }
  function ce(e) {
    const t = W(e);
    let r = null;
    if ((t && (r = t.finishDraft), !r)) throw new Error('not a Limu draft!');
    return r(e);
  }
  function ie(e) {
    if (!T(e)) throw new Error('produce callback is not a function');
  }
  function ue(e, t, r) {
    ie(t);
    const n = se(e, r),
      o = t(n);
    return (
      (function (e, t) {
        if (A(e) || _(t)) throw new Error('produce callback can not be a promise function or result');
      })(t, o),
      ce(n)
    );
  }
  const le = function (e, t, r) {
      if (!t || !T(t)) {
        const r = e,
          n = t;
        return ie(e), (e) => ue(e, r, n);
      }
      return ue(e, t, r);
    },
    fe = Y;
  const pe = function (e) {
      const t = W(e);
      return t ? t.self : e;
    },
    de = function (e) {
      const t = W(e);
      return t ? K(t.copy || t.self) : e;
    };
  (e.VER = '3.6.0'),
    (e.createDraft = se),
    (e.current = de),
    (e.deepCopy = function (e) {
      return K(e);
    }),
    (e.deepFreeze = fe),
    (e.finishDraft = ce),
    (e.getAutoFreeze = function () {
      return O.autoFreeze;
    }),
    (e.immut = function (e, t) {
      return te(Object.assign(Object.assign({}, t || {}), { readOnly: !0, [r]: !0 })).createDraft(e);
    }),
    (e.isDiff = ne),
    (e.isDraft = re),
    (e.limuUtils = ae),
    (e.original = pe),
    (e.produce = le),
    (e.setAutoFreeze = function (e) {
      O.autoFreeze = e;
    }),
    (e.shallowCompare = oe),
    Object.defineProperty(e, '__esModule', { value: !0 });
});
